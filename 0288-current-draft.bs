<pre class='metadata'>
Title: any_invocable
Shortname: D0288
Revision: 5
Status: D
Audience: LWG
Group: WG21
URL: https://htmlpreview.github.io/?https://github.com/mattcalabrese/proposal-unique_function/master/0288-current-draft.html
Editor: Ryan McDougall <mcdougall.ryan@gmail.com>
        Matt Calabrese <metaprogrammingtheworld@gmail.com>
Abstract: This paper proposes a conservative, move-only equivalent of <tt>std::function</tt>.
Date: 2019-07-15
</pre>

Brief History {#History}
========================

This paper started as a proposal by David Krauss, N4543[1], from 2015 and there has
been an open issue in the LEWG bugzilla requesting such a facility since 2014[2].

Since then, the paper has gone through 4 revisions and has been considered in
small groups in LEWG multiple times. Gradual feedback has led to the conservative
proposal seen here. The most-recent draft prior to this was a late-paper written
and presented by Ryan McDougall in LEWGI in San Diego[3]. It included multiple
references to implementations of move-only functions and made a strong case for
the importance of a move-only form of <tt>std::function</tt>.

Feebdack given was encouragement for targetting C++20.

An updated version of that paper was presented on Saturday at the end of the
San Diego meeting. Poll results from that presentation are presented after the
overview in this document.

The revision was presented in Kona, receiving additional polls and feedback, and
was to be forwarded to LWG pending updates reflecting additional poll results. Those
changes have been applied to the wording in this paper. Polls from the LEWG Kona
review are also provided in this document.

Overview {#Overview}
====================

This conservative <tt>any_invocable</tt> is intended to be the same as <tt>std::function</tt>,
with the exceptions of the following:

1. It is move-only.
2. It does not have the const-correctness bug of <tt>std::function</tt> detailed in n4348.[4]
3. It provides support for cv/ref/noexcept qualified function types.
4. It does not have the <tt>target_type</tt> and <tt>target</tt> accessors (direction requested by users and implementors).
4. Invocation has strong preconditions.

Specification {#Specification}
==============================

The following is relative to N4810.[5]

Add &lt;any_invocable&gt; to Table 19 — C++ library headers

<blockquote>
<pre nohighlight>
Header &lt;any_invocable&gt; synopsis [inv.syn]

<tt>namespace std {
  template&lt;class Sig&gt; class any_invocable; // not defined

  template&lt;class R, class... ArgTypes&gt;
    class any_invocable&lt;R(ArgTypes...)&gt; { <em>see below</em> };

  template&lt;class R, class... ArgTypes&gt;
    class any_invocable&lt;R(ArgTypes...) &amp;&gt; { <em>see below</em> };

  template&lt;class R, class... ArgTypes&gt;
    class any_invocable&lt;R(ArgTypes...) &amp;&amp;&gt; { <em>see below</em> };

  template&lt;class R, class... ArgTypes&gt;
    class any_invocable&lt;R(ArgTypes...) const&gt; { <em>see below</em> };

  template&lt;class R, class... ArgTypes&gt;
    class any_invocable&lt;R(ArgTypes...) const &amp;&gt; { <em>see below</em> };

  template&lt;class R, class... ArgTypes&gt;
    class any_invocable&lt;R(ArgTypes...) noexcept&gt; { <em>see below</em> };

  template&lt;class R, class... ArgTypes&gt;
    class any_invocable&lt;R(ArgTypes...) &amp; noexcept&gt; { <em>see below</em> };

  template&lt;class R, class... ArgTypes&gt;
    class any_invocable&lt;R(ArgTypes...) &amp;&amp; noexcept&gt; { <em>see below</em> };

  template&lt;class R, class... ArgTypes&gt;
    class any_invocable&lt;R(ArgTypes...) const noexcept&gt; { <em>see below</em> };

  template&lt;class R, class... ArgTypes&gt;
    class any_invocable&lt;R(ArgTypes...) const &amp; noexcept&gt; { <em>see below</em> };
}</tt>

1 The class definitions for the partial specializations of <tt>any_invocable</tt> mentioned
  above are specified using exposition-only macros <tt>QUAL_OPT</tt>, <tt>QUAL_OPT_REF</tt>,
  and <tt>NOEXCEPT_VAL</tt>, as described below.

2 For each partial specialization of <tt>any_invocable</tt> mentioned above,
  let <tt>QUAL_OPT</tt> be an exposition-only macro defined to be a textual representation
  of the <i>cv</i> and reference qualifiers of the function type parameter of <tt>any_invocable</tt>.

3 [<em>Note:</em>
  For <tt>any_invocable&lt;void() const&gt;</tt>
    - <tt>QUAL_OPT</tt> is <tt>const</tt>
    
  For <tt>any_invocable&lt;void() &amp;&amp;&gt;</tt>
    - <tt>QUAL_OPT</tt> is <tt>&amp;&amp;</tt>

  For <tt>any_invocable&lt;void()&gt;</tt>
    - <tt>QUAL_OPT</tt> is
  ]

4 For each partial specialization of <tt>any_invocable</tt> mentioned above,
let <tt>NOEXCEPT_VAL</tt> be an exposition-only macro defined to be <tt>true</tt> if the function
type parameter of <tt>any_invocable</tt> is noexcept, otherwise <tt>false</tt>.

5 [<em>Note:</em>
  For <tt>any_invocable&lt;void() noexcept&gt;</tt>
    - <tt>NOEXCEPT_VAL</tt> is <tt>true</tt>
    
  For <tt>any_invocable&lt;void()&gt;</tt>
    - <tt>NOEXCEPT_VAL</tt> is <tt>false</tt>
  ]

6 For each partial specialization of <tt>any_invocable</tt> mentioned above, let
  <tt>QUAL_OPT_REF</tt> be an exposition-only macro defined in the following manner:
      - If the function type parameter of <tt>any_invocable</tt> is reference
        qualified, let <tt>QUAL_OPT_REF</tt> be defined as <tt>QUAL_OPT</tt>.

      - Otherwise, let <tt>QUAL_OPT_REF</tt> be defined as <tt>QUAL_OPT&amp;</tt>.

7 [<em>Note:</em>
  For <tt>any_invocable&lt;void() const&gt;</tt>
    - <tt>QUAL_OPT_REF</tt> is <tt>const &amp;</tt>

  For <tt>any_invocable&lt;void() &amp;&amp;&gt;</tt>
    - <tt>QUAL_OPT_REF</tt> is <tt>&amp;&amp;</tt>

  For <tt>any_invocable&lt;void()&gt;</tt>
    - <tt>QUAL_OPT_REF</tt> is <tt>&amp;</tt>
  ]

8 For each partial specialization of <tt>any_invocable</tt> mentioned above, the following is
  a synopsis of that partial specialization and its associated non-member functions.

<tt>namespace std {

  template&lt;class R, class... ArgTypes&gt;
  class any_invocable&lt;R(ArgTypes...) QUAL_OPT noexcept(NOEXCEPT_VAL)&gt; {
  public:
    using result_type = R;

    // 20.14.16.2.1, construct/copy/destroy
    any_invocable() noexcept;
    any_invocable(nullptr_t) noexcept;
    any_invocable(any_invocable&amp;&amp;) noexcept;
    template&lt;class F&gt; any_invocable(F&amp;&amp;);

    template&lt;class T, class... Args&gt;
      explicit any_invocable(in_place_type_t&lt;T&gt;, Args&&...);
    template&lt;class T, class U, class... Args&gt;
      explicit any_invocable(in_place_type_t&lt;T&gt;, initializer_list&lt;U&gt;, Args&amp;&amp;...);
    
    any_invocable&amp; operator=(any_invocable&amp;&amp;) noexcept;
    any_invocable&amp; operator=(nullptr_t) noexcept;
    template&lt;class F&gt; any_invocable&amp; operator=(F&amp;&amp;);
    template&lt;class F&gt; any_invocable&amp; operator=(reference_wrapper&lt;F&gt;) noexcept;

    ~any_invocable();

    // 20.14.16.2.2, any_invocable modifiers
    void swap(any_invocable&amp;) noexcept;

    // 20.14.16.2.3, any_invocable capacity
    explicit operator bool() const noexcept;

    // 20.14.16.2.4, any_invocable invocation
    R operator()(ArgTypes...) QUAL_OPT noexcept(NOEXCEPT_VAL);
  };

  / 20.14.16.2.6, Null pointer comparisons
  template&lt;class R, class... ArgTypes&gt;
    bool operator==(const any_invocable&lt;R(ArgTypes...) QUAL_OPT noexcept(NOEXCEPT_VAL)&gt;&, nullptr_t) noexcept;

  template&lt;class R, class... ArgTypes&gt;
    bool operator==(nullptr_t, const any_invocable&lt;R(ArgTypes...) QUAL_OPT noexcept(NOEXCEPT_VAL)&gt;&) noexcept;

  template&lt;class R, class... ArgTypes&gt;
    bool operator!=(const any_invocable&lt;R(ArgTypes...) QUAL_OPT noexcept(NOEXCEPT_VAL)&gt;&, nullptr_t) noexcept;

  template&lt;class R, class... ArgTypes&gt;
    bool operator!=(nullptr_t, const any_invocable&lt;R(ArgTypes...) QUAL_OPT noexcept(NOEXCEPT_VAL)&gt;&) noexcept;

  // 20.14.16.2.7, specialized algorithms
  template&lt;class R, class... ArgTypes&gt;
    void swap(any_invocable&lt;R(ArgTypes...) QUAL_OPT noexcept(NOEXCEPT_VAL)&gt;&,
        any_invocable&lt;R(ArgTypes...) QUAL_OPT noexcept(NOEXCEPT_VAL)&gt;&) noexcept;
}</tt>

9 The <tt>any_invocable</tt> class template provides polymorphic wrappers that generalize
  the notion of a callable object (20.14.2). These wrappers can store, move, and call
  arbitrary callable objects (20.14.2), given a call signature (20.14.2), allowing
  functions to be first-class objects.

10 A callable type (20.14.2) <tt>F</tt> is Callable for argument types <tt>ArgTypes</tt>
   and return type <tt>R</tt> if the expression
   <tt>INVOKE&lt;R&gt;(declval&lt;F&gt;(), declval&lt;ArgTypes&gt;()...)</tt>,
   considered as an unevaluated operand (7.2), is well-formed (20.14.3).

SECTION.1  Constructors and destructor [inv.wrap.func.con]
any_invocable() noexcept;

1 <em>Ensures:</em> !*this.

<tt>any_invocable(nullptr_t) noexcept;</tt>

2 <em>Ensures:</em> <tt>!*this</tt>.

<tt>any_invocable(any_invocable&amp;&amp; f) noexcept;</tt>

3 <em>Ensures:</em> If <tt>!f</tt>, <tt>*this</tt> has no target; otherwise, the target of <tt>*this</tt>
  is equivalent to the target of <tt>f</tt> before the construction, and <tt>f</tt> is in a valid state
  with an unspecified value.

4 [<em>Note:</em> Implementations should avoid the use of dynamically allocated memory for
   small callable objects,for example, wheref’s target is an object holding only a
   pointer or reference to an object and a member function pointer.— <em>end note</em>]

<tt>template&lt;class F&gt; any_invocable(F&amp;&amp; f);</tt>

5 <em>Requires:</em> <tt>decay&lt;F&gt;</tt> shall be Cpp17MoveConstructible.

6 <em>Constraints:</em>

(6.1) — <tt>decay_t&lt;F&gt;</tt> is not the same type as <tt>any_invocable</tt> and

(6.2) — <tt>decay_t&lt;F&gt;</tt> is not a specialization of <tt>in_place_type_t</tt> and

(6.3) — <tt>is_constructible_v&lt;decay_t&lt;F&gt;, F&gt;</tt> is <tt>true</tt> and

(6.4) — <tt>is_­move_­constructible_­v&lt;decay_t&lt;F&gt;&gt;</tt> is <tt>true</tt> and

(6.5) — <tt>F QUAL_OPT_REF</tt> is Callable (20.14.16.2) for argument types
        <tt>ArgTypes...</tt>, return type <tt>R</tt>, and

(6.6) — <tt>!NOEXCEPT_VAL || noexcept(INVOKE&lt;R&gt;(declval&lt;F QUAL_OPT_REF&gt;(), declval&lt;ArgTypes&gt;()...))</tt> is <tt>true</tt>.

7 <em>Ensures:</em> <tt>!*this</tt> if any of the following hold:

—(7.1) <tt>f</tt> is a null function pointer value.

—(7.2) <tt>f</tt> is a null member pointer value.

—(7.3) <tt>F</tt> is an instance of the <tt>any_invocable</tt> class template, and <tt>!f</tt>. 

8 Otherwise, <tt>*this</tt> targets a copy of <tt>f</tt> initialized with <tt>
  std::forward&lt;F&gt;(f)</tt>. [<em>Note</em>: Implementations should avoid the use of
  dynamically allocated memory for small callable objects, for example, where <tt>f</tt> is
  an object holding only a pointer or reference to an object and a member function
  pointer.— <em>end note</em>]

9 <em>Throws:</em> Shall not throw exceptions when <tt>f</tt> is a function pointer or a
  <tt>reference_wrapper&lt;T&gt;</tt> for some <tt>T</tt>. Otherwise, may throw <tt>bad_alloc</tt>
  or any exception thrown by the expression <tt>decay_t&lt;F&gt;(std::forward&lt;F&gt;(f))</tt>.

<tt>template&lt;class T, class... Args&gt;
  explicit any_invocable(in_place_type_t&lt;T&gt;, Args&amp;&amp;... args);</tt>

10 Let <tt>VT</tt> be <tt>decay_t&lt;T&gt;</tt>.

11 <em>Requires:</em> <tt>VT</tt> shall be Cpp17MoveConstructible.

12 <em>Constraints:</em>

(12.1) — <tt>is_constructible_v&lt;VT, Args...&gt;</tt> is <tt>true</tt> and

(12.2) — <tt>is_­move_­constructible_­v&lt;VT&gt;</tt> is <tt>true</tt> and

(12.3) — <tt>VT QUAL_OPT_REF</tt> is Callable (20.14.16.2) for argument types
         <tt>ArgTypes...</tt>, return type <tt>R</tt>, and

(12.4) — <tt>!NOEXCEPT_VAL || noexcept(INVOKE&lt;R&gt;(declval&lt;F QUAL_OPT_REF&gt;(), declval&lt;ArgTypes&gt;()...))</tt> is <tt>true</tt>.

13 <em>Ensures:</em> <tt>*this</tt> targets an object of type <tt>VT</tt> initialized
   with <tt>std::forward&lt;Args&gt;(args)...</tt> by <i>direct-non-list-initialization</i>. [<em>Note</em>:
   Implementations should avoid the use of dynamically allocated memory for small
   callable objects, for example, where <tt>f</tt> is an object holding only a pointer or 
   reference to an object and a member function pointer.— <em>end note</em>]

<tt>template&lt;class T, class U, class... Args&gt;
  explicit any_invocable(in_place_type_t&lt;T&gt;, initializer_list&lt;U&gt; ilist, Args&amp;&amp;... args);</tt>

14 Let VT be decay_t&lt;T&gt;.

15 <em>Requires:</em> <tt>VT</tt> shall be Cpp17MoveConstructible.

16 <em>Constraints:</em>

(16.1) — <tt>is_constructible_v&lt;VT, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt> and

(16.2) — <tt>is_­move_­constructible_­v&lt;VT&gt;</tt> is <tt>true</tt> and

(16.3) — <tt>VT QUAL_OPT_REF</tt> is Callable (20.14.16.2) for argument types
         <tt>ArgTypes...</tt>, return type <tt>R</tt>, and

(16.4) — <tt>!NOEXCEPT_VAL || noexcept(INVOKE&lt;R&gt;(declval&lt;F QUAL_OPT_REF&gt;(), declval&lt;ArgTypes&gt;()...))</tt> is <tt>true</tt>.

17 <em>Ensures:</em> <tt>*this</tt> targets an object of type <tt>VT</tt> initialized
   with <tt>ilist, std::forward&lt;ArgTypes&gt;(args)...</tt> by <i>direct-non-list-initialization</i>. [<em>Note</em>:
   Implementations should avoid the use of dynamically allocated memory for small
   callable objects, for example, where <tt>f</tt> is an object holding only a pointer or
   reference to an object and a member function pointer.— <em>end note</em>]

<tt>any_invocable&amp; operator=(any_invocable&amp;&amp; f) noexcept;</tt>

18 <em>Effects:</em> Replaces the target of <tt>*this</tt> with the target of <tt>f</tt>.

19 <em>Returns:</em> <tt>*this</tt>.

<tt>any_invocable&amp; operator=(nullptr_t) noexcept;</tt>

20 <em>Effects:</em> If <tt>*this != nullptr</tt>, destroys the target of <tt>this</tt>.

21 <em>Ensures:</em> <tt>!(*this)</tt>.

22 <em>Returns:</em> <tt>*this</tt>.

<tt>template&lt;class F&gt; any_invocable&amp; operator=(F&amp;&amp; f);</tt>

23 <em>Effects:</em> As if by: <tt>any_invocable(std::forward&lt;F&gt;(f)).swap(*this);</tt>

24 <em>Returns:</em> <tt>*this.</tt>

25 <em>Requires:</em> <tt>decay&lt;F&gt;</tt> shall be Cpp17MoveConstructible.

26 <em>Constraints:</em>

(26.1) — <tt>decay_t&lt;F&gt;</tt> is not the same type as <tt>any_invocable</tt> and

(26.3) — <tt>is_constructible_v&lt;decay_t&lt;F&gt;, F&gt;</tt> is <tt>true</tt> and

(26.4) — <tt>is_­move_­constructible_­v&lt;decay_t&lt;F&gt;&gt;</tt> is <tt>true</tt> and

(26.5) — <tt>F QUAL_OPT_REF</tt> is Callable (20.14.16.2) for argument types
         <tt>ArgTypes...</tt>, return type <tt>R</tt>, and

(26.4) — <tt>!NOEXCEPT_VAL || noexcept(INVOKE&lt;R&gt;(declval&lt;F QUAL_OPT_REF&gt;(), declval&lt;ArgTypes&gt;()...))</tt> is <tt>true</tt>.

template&lt;class F&gt; any_invocable&amp; operator=(reference_wrapper&lt;F&gt; f) noexcept;

27 <em>Effects:</em> As if by: <tt>any_invocable(f).swap(*this);</tt>

28 <em>Returns:</em> <tt>*this</tt>.

<tt>~any_invocable()</tt>;

29 <em>Effects:</em> If <tt>*this != nullptr</tt>, destroys the target of <tt>this</tt>.

SECTION.2  Modifiers [inv.wrap.func.mod]
<tt>void swap(any_invocable&amp; other) noexcept;</tt>

1 <em>Effects:</em> Interchanges the targets of <tt>*this</tt> and <tt>other</tt>.

SECTION.3  Capacity [inv.wrap.func.cap]
<tt>explicit operator bool() const noexcept;</tt>

1 <em>Returns:</em> <tt>true</tt> if *<tt>this</tt> has a target, otherwise <tt>false</tt>.

SECTION.4  Invocation [inv.wrap.func.inv]
<tt>R operator()(ArgTypes... args) QUAL_OPT noexcept(NOEXCEPT_VAL);</tt>

1 <em>Returns:</em> <tt>INVOKE&lt;R&gt;(static_cast&lt;decltype(f) QUAL_OPT_REF&gt;(f),
  std​::​forward&lt;ArgTypes&gt;(args)...)</tt> , where <tt>f</tt> is the target object of <tt>*this</tt>,.

2 <em>Requires:</em> <tt>(bool)*this</tt> is <tt>true</tt>.

3 <em>Throws:</em> Any exception thrown by the wrapped callable object.

SECTION.5  Null pointer comparison functions [inv.wrap.func.nullptr]
<tt>template&lt;class R, class... ArgTypes&gt;
  bool operator==(const any_invocable&lt;R(ArgTypes...) QUAL_OPT noexcept(NOEXCEPT_VAL)&gt;&amp; f, nullptr_t) noexcept;
template&lt;class R, class... ArgTypes&gt;
  bool operator==(nullptr_t, const any_invocable&lt;R(ArgTypes...) QUAL_OPT noexcept(NOEXCEPT_VAL)&gt;&amp; f) noexcept;</tt>

1 <em>Returns:</em> <tt>!f</tt>.

<tt>template&lt;class R, class... ArgTypes&gt;
  bool operator!=(const any_invocable&lt;R(ArgTypes...) QUAL_OPT noexcept(NOEXCEPT_VAL)&gt;&amp; f, nullptr_t) noexcept;
template&lt;class R, class... ArgTypes&gt;
  bool operator!=(nullptr_t, const any_invocable&lt;R(ArgTypes...) QUAL_OPT noexcept(NOEXCEPT_VAL)&gt;&amp; f) noexcept;</tt>

2 <em>Returns:</em> <tt>(bool)f</tt>.

SECTION.6  Specialized algorithms [inv.wrap.func.alg]
<tt>template&lt;class R, class... ArgTypes&gt;
  void swap(any_invocable&lt;R(ArgTypes...) QUAL_OPT noexcept(NOEXCEPT_VAL)&gt;&amp; f1,
      any_invocable&lt;R(ArgTypes...) QUAL_OPT noexcept(NOEXCEPT_VAL)&gt;&amp; f2) noexcept;</tt>

1 Effects:As if by: <tt>f1.swap(f2)</tt>

</pre>
</blockquote>

Polls from LEWG San Diego Review (2018) {#SD2018}
=================================================

## Support func(), func() const, func() &&

<pre>
SF F N A SA
6  6 2 1 0
</pre>

## Support func() && only

<pre>
SF F N A SA
2  2 7 1 1
</pre>

## Remove target/target_type

<pre>
SF F N A SA
12 5 0 0 0
</pre>

## Require more stuff (noexcept, const&&, ...)

<pre>
SF F N A SA
0  1 8 6 0
</pre>

Note that the final poll (require more stuff) was not due to members being
against the design, but because we could easily add those facilities in a later
standard without any breakage.

## Name Options

There was one final poll, which brought us to the name <tt>any_invocable</tt>.

<pre>
3  unique_function
3  move_function
2  move_only_function
7  movable_function
8  mfunction
10 any_invocable
8  mofun
8  mofunc
0  callback
4  mvfunction
2  func
0  callable
2  any_function
</pre>

Polls from LEWG Kona Review (2019) {#K2019}
=================================================

## We want to spend time on this now in order to include it in C++20 

<pre>
SF F N A SA
8  8 2 0 0
</pre>

## Add support for func() const& and func()&

<pre>
SF F N A SA
0  8 7 0 0
</pre>

## Add support for func() noexcept (x all of the above)

<pre>
SF F  N A SA
2  12 2 0 0
</pre>

## Include the option for CTAD

<pre>
SF F N A SA
0  1 5 9 0
</pre>

## Name: callable vs any invocable

<pre>
SC C N AI SAI
3  2 3 5  6
</pre>

## any_invocable vs invocable

<pre>
SAI AI N I SI
3   7  2 5 1
</pre>

## Header choice

<pre>
7 &lt;functional&gt;
11 &lt;any_invocable&gt;
11 &lt;invocable&gt;
3 &lt;()&gt;
</pre>

## Can get std::function from &lt;any_invocable&gt; 

<pre>
SF F N A SA
0  1 4 4 7
</pre>

## Can get std::function from &lt;invocable&gt;

<pre>
SF F N A SA
1  3 6 3 2
</pre>

Decide on &lt;any_invocable&gt;. Unanimous for &lt;functional&gt; to pull it in,
even if in its own header.

## Remove the null-check in the call operator and throwing of bad_function_call

<pre>
SF F N A SA
8  2 1 0 0
</pre>

## Remove the null-check in constructors that are not nullptr_t

<pre>
std::any_callable<void(void)> ac = my_ptr_object;
if(ac)  { /* true even if my_ptr is nullptr */ }
</pre>

<pre>
SF F N A SA
0  2 2 4 3
</pre>

## Perfect forwarding for converting constructor instead of by-value

Unanimous

## Forward to LWG for C++20

<pre>
SF F N A SA
8  5 0 0 0
</pre>

Implementation Experience {#Impl}
=================================

There are many implementations of a move-only <tt>std::function</tt> with a
design that is similar to this. What is presented is a conservative subset of
those implementations. The changes suggested in LEWG, though minimal, have not
been used in a large codebase.

Previous revisions of this paper have included publicly accessible move-only
function implementations, notably including implementations in HPX, Folly, and
LLVM.

References {#References}
========================

[1]: David Krauss: N4543 "A polymorphic wrapper for all Callable objects" <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4543.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4543.pdf</a>

[2]: Geoffrey Romer: "Bug 34 - Need type-erased wrappers for move-only callable objects" <a href="https://issues.isocpp.org/show_bug.cgi?id=34">https://issues.isocpp.org/show_bug.cgi?id=34</a>

[3]: Ryan McDougall: P0288R2 "The Need for std::unique_function" <a href="https://wg21.link/p0288r2">https://wg21.link/p0288r2</a>

[4]: Geoffrey Romer: N4348 "Making std::function safe for concurrency" <a href="www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4348.html">www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4348.html</a>

[5]: Richard Smith: N4778 "Working Draft, Standard for Programming Language C++" <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/n4810.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/n4810.pdf</a>
