<pre class='metadata'>
Title: mofunction
Shortname: D0288
Revision: 4
Status: D
Audience: LEWG
Group: WG21
URL: http://wg21.link/p0288r4
Editor: Ryan McDougall <mcdougall.ryan@gmail.com>
        Matt Calabrese <metaprogrammingtheworld@gmail.com>
Abstract: This paper proposes   a conservative, move-only equivalent of <tt>std::function</tt>.
Date: 2019-02-21
</pre>

Brief History {#History}
========================

This paper started as a proposal by David Krauss, N4543[1], from 2015 and there has
been an open issue in the LEWG bugzilla requesting such a facility since 2014[2].

Since then, the paper has gone through 4 revisions and has been considered in
small groups in LEWG multiple times. Gradual feedback has led to the conservative
proposal seen here. The most-recent draft prior to this was a late-paper written
and presented by Ryan McDougall in LEWGI in San Diego[3]. It included multiple
references to implementations of move-only functions and made a strong case for
the importance of a move-only form of <tt>std::function</tt>.

Feebdack given was encouragement for targetting C++20.

An updated version of that paper was presented on Saturday at the end of the
San Diego meeting. Poll results from that presentation are presented after the
overview in this document.

Overview {#Overview}
====================

This conservative <tt>mofunction</tt> is intended to be the same as <tt>std::function</tt>,
with the exceptions of the following:

1. It is move-only.
2. It does not have the const-correctness bug of <tt>std::function</tt> detailed in n4348.[4]
3. It provides minimal support for cv/ref qualified function types.
4. It does not have the <tt>target_type</tt> and <tt>target</tt> accessors (direction requested by users and implementors).

Polls from LEWG San Diego Review (2018) {#SD2018}
=================================================

## Support func(), func() const, func() &&

<pre>
SF F N A SA
6  6 2 1 0
</pre>

## Support func() && only

<pre>
SF F N A SA
2  2 7 1 1
</pre>

## Remove target/target_type

<pre>
SF F N A SA
12 5 0 0 0
</pre>

## Require more stuff (noexcept, const&&, ...)

<pre>
SF F N A SA
0  1 8 6 0
</pre>

Note that the final poll (require more stuff) was not due to members being
against the design, but because we could easily add those facilities in a later
standard without any breakage.

## Name Options

There was one final poll, which brought us to the name <tt>mofunction</tt>.

<pre>
3  unique_function
3  move_function
2  move_only_function
7  movable_function
8  mfunction
10 mofunction
8  mofun
8  mofunc
0  callback
4  mvfunction
2  func
0  callable
2  any_function
</pre>

Summary of Changes {#Changes}
=============================

The following is not formal wording. It is an explanation of how this template
and its specializations would differ from the specification of <tt>std::function</tt>
relative to the WP from the most recent mailing, N4778.[5]

Add (for simplicity, class-definitions are not inlined here):

[func.wrap.func]

<pre>
template&lt;class Sig&gt; class mofunction; // not defined

template&lt;class R, class... ArgTypes&gt;
  class mofunction&lt;R(ArgTypes...)&gt;;

<ins>template&lt;class R, class... ArgTypes&gt;
  class mofunction&lt;R(ArgTypes...) const&gt;;

template&lt;class R, class... ArgTypes&gt;
  class mofunction&lt;R(ArgTypes...)&amp;&amp;&gt;;</ins>
</pre>

In [func.wrap.func.con]

Do not provide a copy constructor:

<blockquote>
<pre nohighlight>
<del><tt>mofunction(const mofunction& f);</tt></del>
</pre>
</blockquote>

Do not provide a copy-assigment operator: 

<blockquote>
<pre nohighlight>
<del><tt>mofunction& operator=(const mofunction& f);</tt></del>
</pre>
</blockquote>

In [func.wrap.func] specify the following wording for aid in describing the provided <tt>mofunction</tt>
partial specializations.

<blockquote>
<pre nohighlight>
Let QUAL_OPT be an exposition-only macro defined to be a textual representation
of the qualifiers of the function type parameter of <tt>mofunction</tt>.

[<em>Note:</em>
  For mofunction&lt;void() const&gt;
    - QUAL_OPT is const
    
  For mofunction&lt;void() &amp;&amp;&gt;
    - QUAL_OPT is &&

  For mofunction&lt;void()&gt;
    - QUAL_OPT is
]

Let QUAL_OPT_REF be an exposition-only macro defined in the following manner:
    - If the function type parameter of <tt>mofunction</tt> is reference
      qualified, let QUAL_OPT_REF be defined as QUAL_OPT.

    - Otherwise, let QUAL_OPT_REF be defined as QUAL_OPT&.

[<em>Note:</em>
  For mofunction&lt;void() const&gt;
    - QUAL_OPT_REF is const&

  For mofunction&lt;void() &amp;&amp;&gt;
    - QUAL_OPT_REF is &&

  For mofunction&lt;void()&gt;
    - QUAL_OPT_REF is &
]
</pre>

</blockquote>

Update the function signature of <tt>operator()</tt> to match the template
parameter exactly, and invoke the contained Callable with the correct cv
qualification and value category (this prevents duplicating the const-correctness
issues of std::function).

In [func.wrap.func.inv]
<blockquote>
<pre nohighlight>
R operator()(ArgTypes... args)<del>const</del> <ins>QUAL_OPT</ins>;
</pre>
<em>Returns:</em> <tt>INVOKE&lt;R&gt;(<ins>static_cast&lt;decltype(f) QUAL_OPT_REF&gt;(</ins>f<ins>)</ins>,
    std​::​forward&lt;ArgTypes&gt;(args)...)</tt> , where f is the unqualified
    target object of <tt>*this</tt>, <ins></.

<em>Throws:</em> <tt>bad_­function_­call</tt> if <tt>!*this</tt>; otherwise, any exception thrown by the
    wrapped callable object.
</blockquote>

In [func.wrap.func.con] regarding the constructor taking a Callable, have a
movability requirement instead of a copyability requirement and also require the
correct kind of Callable:

<blockquote>
<pre nohighlight>
    template&lt;class F&gt; mofunction(F f)
</pre>
    <em>Requires:</em> F shall be <del>Cpp17CopyConstructible </del><ins>Cpp17MoveConstructible</ins>

    <em>Remarks:</em> This constructor shall not participate in overload resolution unless
    <tt>decay_­t&lt;F&gt; <ins>QUAL_OPT_REF </ins></tt> is <del>Lvalue-</del>Callable for
    argument types <tt>ArgTypes...</tt> and return type <tt>R</tt>.
</blockquote>

Do the same for the converting assignment:

<blockquote>
<pre nohighlight>
template&lt;class F&gt; mofunction& operator=(F&& f);
</pre>
<em>Effects:</em> As if by: <tt>mofunction(std​::​forward&lt;F&gt;(f)).swap(*this);</tt>

<em>Returns:</em> *this.

<em>Remarks:</em> This assignment operator shall not participate in overload
    resolution unless <tt>decay_­t&lt;F&gt;<ins> QUAL_OPT_REF</ins></tt> is <del>Lvalue-</del>Callable for
    argument types <tt>ArgTypes...</tt> and return type <tt>R</tt>.
</blockquote>

Additionally, we suggest not including <tt>target</tt> and <tt>target_type</tt>, while being open to
the possibility of proposing it for C++23:

<blockquote>
<pre nohighlight><del>
const type_info& target_type() const noexcept;

template&lt;class T&gt; T* target() noexcept;
template&lt;class T&gt; const T* target() const noexcept;
</del></pre>
</blockquote>

Do not provide deduction guides (deduction of qualifiers is questionable):

<blockquote>
<pre nohighlight>
<del>template&lt;class R, class... ArgTypes&gt;
  function(R(*)(ArgTypes...)) -&gt; function&lt;R(ArgTypes...)&gt;;

template&lt;class F&gt; function(F) -&gt; function&lt;<i>see below</i>&gt;;</del>
</pre>
</blockquote>

Implementation Experience {#Impl}
=================================

There are many implementations of a move-only <tt>std::function</tt> with a
design that is similar to this. What is presented is a conservative subset of
those implementations.

Previous revisions of this paper have included publicly accessible move-only
function implementations, notably including implementations in HPX, Folly, and
LLVM.

Possible Alternative {#Alt}
===========================

It is not recommended that we provide deduction guides due to subtleties
regarding sensible deduction of qualifiers. If we wish to start with a
deduction guide, we can do so, but the following deduction guide has not been
used in practice. If specified, they should also deduce all forms of cv/ref/noexcept
qualifiers so-as to be forwards-compatible with any support for such facilities that
may be added in the future (being ill-formed if deduced today):

<blockquote>
<pre nohighlight>
template&lt;class R, class... ArgTypes&gt;
  mofunction(R(*)(ArgTypes...)) -&gt; mofunction&lt;R(ArgTypes...) const&gt;

template&lt;class R, class... ArgTypes&gt;
  mofunction(R(*)(ArgTypes...) noexcept) -&gt; mofunction&lt;R(ArgTypes...) const noexcept&gt;

template&lt;class F&gt;
  mofunction(F) -&gt; mofunction&lt;see below&gt;;

  <i>Remarks</i>: This deduction guide participates in overload resolution only if
  <tt>&amp;F::operator()</tt> is well-formed when treated as an unevaluated operand. In that case,
  if <tt>decltype(&amp;F::operator())</tt> is a member function pointer type with a corresponding
  function type <tt>FT</tt> (including any <i>cv</i> and reference qualifiers or <tt>noexcept</tt> specifier), the
  deduced type is <tt>mofunction&lt;FT&gt;</tt>.

  [<i>Example</i>:
   void f() {
     int i{5};
     mofunction g = [&](double) { return i; }; // deduces mofunction&lt;int(double)const&gt;
   }

   — <i>end example</i>
  ]
</pre>
</blockquote>

Suggested Polls {#Polls}
========================

Proposal as-is

Proposal without <tt>std::function</tt>-like <tt>std::bad_function_call</tt> on invocation of empty (make it a precondition violation -- may be migration concerns from <tt>std::function</tt>)

Proposal without <tt>std::function</tt>-like null Callable checking leading to empty (may be migration concerns from <tt>std::function</tt>)

Proposal with perfect-forwarding converting constructor instead of by-value

Proposal with deduction guides

Secondary name bikeshedding???

References {#References}
========================

[1]: David Krauss: N4543 "A polymorphic wrapper for all Callable objects" <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4543.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4543.pdf</a>

[2]: Geoffrey Romer: "Bug 34 - Need type-erased wrappers for move-only callable objects" <a href="https://issues.isocpp.org/show_bug.cgi?id=34">https://issues.isocpp.org/show_bug.cgi?id=34</a>

[3]: Ryan McDougall: P0288R2 "The Need for std::unique_function" <a href="https://wg21.link/p0288r2">https://wg21.link/p0288r2</a>

[4]: Geoffrey Romer: N4348 "Making std::function safe for concurrency" <a href="www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4348.html">www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4348.html</a>

[5]: Richard Smith: N4778 "Working Draft, Standard for Programming Language C++" <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4778.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4778.pdf</a>
